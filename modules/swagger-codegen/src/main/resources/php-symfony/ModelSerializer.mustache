<?php
/**
 * ModelSerializer
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{modelPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{modelPackage}};

/**
 * ModelSerializer Class Doc Comment
 *
 * @category Class
 * @package  {{modelPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ModelSerializer
{
    /**
     * Serializes data to a given type format.
     *
     * @param mixed $data     The data to serialize.
     * @param string $format  The target serialization format.
     *
     * @return string  A serialized data string.
     * @throws \InvalidArgumentException When invalid serialization format was used.
     */
    public function serialize($data, $format)
    {
        $normalized = $this->normalize($data);
        if ($format === 'json') {
            return json_encode($normalized, 13, 512);
        }

        throw new \InvalidArgumentException('Unsupported serialization format: '.$format);
    }

    /**
     * De-serializes data from a given type format.
     *
     * @param string $data   The data to deserialize.
     * @param string $class  The target class to deserialize to.
     * @param string $format The source serialization format.
     *
     * @return mixed  A de-serialized value.
     * @throws \InvalidArgumentException When invalid serialization format was used.
     */
    public function deserialize($data, $class, $format)
    {
        switch ($format) {
            case 'json':
                if (version_compare(PHP_VERSION, '5.4.0', '>=') && !(defined('JSON_C_VERSION') && PHP_INT_SIZE > 4)) {
                    // In PHP >=5.4.0, json_decode() accepts an options parameter, that allows you
                    // to specify that large int (like Steam Transaction IDs) should be treated as
                    // strings, rather than the PHP default behaviour of converting them to floats.
                    $normalized = json_decode($data, true, 512, 15);
                } else {
                    // Not all servers will support that, however, so for older versions we must
                    // manually detect large int in the JSON string and quote them (thus converting
                    // them to strings) before decoding, hence the preg_replace() call.
                    $max_int_length = strlen((string) PHP_INT_MAX) - 1;
                    $json_without_bigint = preg_replace('/:\s*(-?\d{' . $max_int_length . ',})/', ': "$1"', $data);
                    $normalized = json_decode($json_without_bigint, true, 512, 13);
                }
                break;
            default:
                throw new \InvalidArgumentException('Unsupported serialization format: '.$format);
        }

        return $this->denormalize($normalized, $class);
    }

    /**
     * Normalizes data for a given type format.
     *
     * @param mixed       $data
     * @param string|null $format
     *
     * @return mixed
     * @throws \InvalidArgumentException
     */
    public function normalize($data, $format = null)
    {
        if (is_scalar($data) || null === $data) {
            return $data;
        }

        if (is_array($data)) {
            return array_map(function ($value) use ($format) {
                return $this->normalize($value, $format);
            }, $data);
        }

        if ($data instanceof \DateTime) {
            return ($format === 'date') ? $data->format('Y-m-d') : $data->format(\DateTime::ATOM);
        }

        if ($data instanceof ModelInterface) {
            $values = [];
            foreach ($data->modelAttributes() as $name => $attribute) {
                list($baseName, , $format, , $getter) = $attribute;
                $value = $this->normalize($data->$getter(), $format);
                if ($value !== null && method_exists($data, 'getAllowableEnumValues')
                    && !in_array($value, $data::getAllowableEnumValues())) {
                    $imploded = implode("', '", $data::getAllowableEnumValues());
                    throw new \InvalidArgumentException("Invalid value for enum '$data', must be one of: '$imploded'");
                }

                if ($value !== null) {
                    $values[$baseName] = $value;
                }
            }

            return $values;
        }

        return (string) $data;
    }

    /**
     * De-normalizes data for a given class and type format.
     *
     * @param mixed       $data
     * @param string      $class
     * @param string|null $format
     *
     * @return mixed
     * @throws \InvalidArgumentException
     */
    public function denormalize($data, $class, $format = null)
    {
        if ($data === null) {
            return null;
        }

        $basicTypes = ['boolean', 'bool', 'integer' , 'int', 'float', 'double', 'string', 'array', 'null'];
        if (in_array($class, $basicTypes, true)) {
            settype($data, $class);
            return $data;
        }

        // De-normalize array
        if (substr($class, -2) === '[]') {
            $innerClass = substr($class, 0, -2);
            return array_map(function ($value) use ($format, $innerClass) {
                return $this->denormalize($value, $innerClass, $format);
            }, $data);
        }

        if (!class_exists($class)) {
            return $data;
        }

        $reflectionClass = new \ReflectionClass($class);

        if ($reflectionClass->getName() === 'DateTime') {
            return new \DateTime($data);
        }

        if ($reflectionClass->implementsInterface(ModelInterface::class)) {
            // De-normalize enum
            if (method_exists($class, 'getAllowableEnumValues')) {
                if (!in_array($data, $class::getAllowableEnumValues())) {
                    $imploded = implode("', '", $class::getAllowableEnumValues());
                    throw new \InvalidArgumentException("Invalid value for enum '$class', must be one of: '$imploded'");
                }

                return $data;
            }

            // If a discriminator is defined and points to a valid subclass, use it.
            $discriminator = $reflectionClass->getConstant('DISCRIMINATOR');

            if (!empty($discriminator) && isset($data[$discriminator]) && is_string($data[$discriminator])) {
                $subclass = 'Sponsoo\Bundle\SwaggerBundle\Model\\'.$data[$discriminator];
                if (is_subclass_of($subclass, $class)) {
                    $class = $subclass;
                }
            }

            /** @var ModelInterface $values */
            $values = new $class();

            foreach ($values->modelAttributes() as $name => $attribute) {
                list($baseName, $innerClass, $format, $setter) = $attribute;

                if (!isset($data[$baseName])) {
                    continue;
                }

                $value = $this->denormalize($data[$baseName], $innerClass, $format);
                $values->$setter($value);
            }

            return $values;
        }

        throw new \InvalidArgumentException(sprintf('Unable to de-normalize unknown class `%s`.', $class));
    }
}
